{
  "nombre": "Clean Architecture / Layered Architecture para Go",
  "descripcion": "Arquitectura base para aplicaciones backend en Go con API REST",
  "version": "1.0",
  "lenguaje": "Go",
  "tipo_aplicacion": "Backend REST API",

  "principios_fundamentales": {
    "solid": {
      "single_responsibility": "Cada capa y componente tiene una única responsabilidad",
      "open_closed": "Abierto para extensión, cerrado para modificación (uso de interfaces)",
      "liskov_substitution": "Las implementaciones pueden ser sustituidas (ej: repositorios)",
      "interface_segregation": "Interfaces pequeñas y específicas",
      "dependency_inversion": "Dependencias apuntan hacia abstracciones (interfaces)"
    },
    "clean_architecture": {
      "independencia_frameworks": "La lógica de negocio no depende de frameworks externos",
      "testeable": "Reglas de negocio pueden testearse sin UI, BD, servidor",
      "independencia_ui": "La UI puede cambiar sin afectar el negocio",
      "independencia_bd": "Puedes cambiar de PostgreSQL a MongoDB sin tocar el negocio",
      "independencia_externos": "Las reglas de negocio no saben de servicios externos"
    }
  },

  "estructura_directorios": {
    "raiz": {
      "cmd/": {
        "proposito": "Puntos de entrada de la aplicación",
        "descripcion": "Contiene el main.go y configuración inicial",
        "ejemplo": "cmd/api/main.go - Punto de entrada de la API REST",
        "responsabilidad": "Orquestar la inicialización: config, DB, router, server",
        "capa": "Infraestructura"
      },
      "internal/": {
        "proposito": "Código privado de la aplicación (no exportable fuera del módulo)",
        "descripcion": "Toda la lógica de la aplicación vive aquí",
        "subdirectorios": {
          "config/": {
            "proposito": "Gestión de configuración",
            "archivos": ["config.go"],
            "responsabilidad": "Cargar variables de entorno, configuración general",
            "capa": "Infraestructura"
          },
          "domain/": {
            "proposito": "Núcleo de la aplicación - Lógica de negocio",
            "descripcion": "Cada subdominio tiene su propia carpeta con estructura estándar",
            "estructura_dominio": {
              "model.go": {
                "proposito": "Entidades del dominio",
                "contiene": "Structs que representan conceptos del negocio",
                "ejemplo": "type User struct { ID int64; Email string; ... }"
              },
              "dto.go": {
                "proposito": "Data Transfer Objects",
                "contiene": "Objetos para transferir datos entre capas",
                "metodos": ["ToModel()", "ToUpdateData()"],
                "ejemplo": "type UserDTO struct { Email string `json:\"email\"` }"
              },
              "errors.go": {
                "proposito": "Errores específicos del dominio",
                "contiene": "Variables de error semánticas",
                "ejemplo": "var ErrUserNotFound = errors.New(\"user not found\")"
              },
              "repository.go": {
                "proposito": "Abstracción de persistencia (Puerto Secundario)",
                "contiene": [
                  "Repository interface - Define operaciones CRUD",
                  "Criteria struct - Filtros de búsqueda",
                  "UpdateData struct - Datos de actualización",
                  "repository struct (privado) - Implementación",
                  "Constructor NewRepository(db) Repository"
                ],
                "patron": "Repository Pattern + Criteria Pattern"
              },
              "service.go": {
                "proposito": "Lógica de negocio (Puerto Primario)",
                "contiene": [
                  "Service interface - Define casos de uso",
                  "service struct (privado) - Implementación",
                  "Constructor NewService(repo) Service",
                  "Validaciones de negocio",
                  "Orquestación de repositorios"
                ],
                "patron": "Service Layer Pattern"
              }
            },
            "capa": "Dominio + Aplicación"
          },
          "http/": {
            "proposito": "Adaptador HTTP (Capa de Presentación)",
            "descripcion": "Expone la API REST usando un framework HTTP",
            "subdirectorios": {
              "handler/": {
                "proposito": "Controladores HTTP",
                "responsabilidad": "Recibir requests, llamar services, retornar responses",
                "patron": "Adapter Pattern",
                "estructura": "Un handler por dominio: user_handler.go, product_handler.go"
              },
              "middleware/": {
                "proposito": "Middlewares HTTP",
                "responsabilidad": "Autenticación, autorización, logging, CORS",
                "patron": "Chain of Responsibility",
                "ejemplos": ["auth.go - JWT validation", "api_key.go - API Key validation"]
              },
              "utils/": {
                "proposito": "Utilidades HTTP",
                "contiene": ["Helpers para requests/responses", "Claims JWT", "Response wrappers"]
              },
              "router.go": {
                "proposito": "Configuración de rutas y Dependency Injection",
                "responsabilidad": [
                  "Crear instancias (repos, services, handlers)",
                  "Inyectar dependencias",
                  "Registrar rutas",
                  "Configurar middlewares"
                ],
                "patron": "Dependency Injection + Factory"
              }
            },
            "capa": "Presentación"
          }
        }
      },
      "pkg/": {
        "proposito": "Paquetes reutilizables y exportables",
        "descripcion": "Código que podría ser usado por otros proyectos",
        "subdirectorios": {
          "db/": {
            "proposito": "Adaptador de base de datos",
            "archivos": ["postgres.go", "mysql.go", "factory/", "models/"],
            "responsabilidad": "Conexión a BD, modelos generados por ORM",
            "capa": "Infraestructura"
          },
          "logger/": {
            "proposito": "Sistema de logging",
            "archivos": ["logger.go"],
            "responsabilidad": "Abstracción de logs",
            "capa": "Infraestructura"
          },
          "jwt/": {
            "proposito": "Manejo de tokens JWT",
            "archivos": ["jwt.go", "params.go"],
            "responsabilidad": "Generación y validación de tokens",
            "capa": "Infraestructura"
          }
        },
        "capa": "Infraestructura"
      },
      "utils/": {
        "proposito": "Utilidades generales",
        "descripcion": "Funciones helper reutilizables",
        "ejemplos": ["errors.go", "ptr.go - Helpers de punteros", "func.go - Map, Filter"],
        "capa": "Infraestructura"
      }
    }
  },

  "capas_arquitectura": {
    "orden_dependencias": "Presentación → Aplicación → Dominio ← Persistencia ← Infraestructura",
    "regla_oro": "Las capas internas NO conocen las externas",

    "capa_1_presentacion": {
      "nombre": "Presentación / Delivery Layer",
      "ubicacion": "internal/http/",
      "responsabilidad": "Adaptar protocolos externos (HTTP, gRPC, CLI) al dominio",
      "componentes": ["Handlers", "Middlewares", "Router"],
      "ejemplo_handler": "UserHandler recibe JSON, llama UserService, retorna JSON",
      "que_hace": [
        "Recibir requests HTTP",
        "Validar formato básico (JSON válido)",
        "Transformar request a DTO",
        "Llamar al service correspondiente",
        "Transformar respuesta del service a HTTP",
        "Manejar códigos de estado HTTP"
      ],
      "que_NO_hace": [
        "Validar reglas de negocio",
        "Acceder directamente a la BD",
        "Contener lógica de negocio"
      ]
    },

    "capa_2_aplicacion": {
      "nombre": "Aplicación / Use Cases Layer",
      "ubicacion": "internal/domain/*/service.go",
      "responsabilidad": "Orquestar la lógica de negocio y casos de uso",
      "componentes": ["Service interfaces", "Service implementations"],
      "ejemplo_service": "UserService.Register() valida, verifica duplicados, persiste",
      "que_hace": [
        "Validar datos (formato, reglas de negocio)",
        "Aplicar reglas de negocio",
        "Orquestar llamadas a repositorios",
        "Coordinar transacciones",
        "Manejar errores del dominio"
      ],
      "que_NO_hace": [
        "Conocer HTTP (no sabe de requests/responses)",
        "Hacer SQL directo",
        "Conocer qué BD se usa"
      ]
    },

    "capa_3_dominio": {
      "nombre": "Dominio / Entities Layer",
      "ubicacion": "internal/domain/*/model.go, dto.go, errors.go",
      "responsabilidad": "Representar conceptos del negocio",
      "componentes": ["Models", "DTOs", "Domain Errors"],
      "ejemplo_modelo": "User, Product, Order son entidades del negocio",
      "que_contiene": [
        "Estructuras de datos del dominio",
        "DTOs para transferencia de datos",
        "Errores específicos del dominio",
        "Métodos de transformación (ToModel, ToDTO)"
      ],
      "que_NO_contiene": [
        "Lógica de persistencia",
        "Lógica de presentación",
        "Detalles de frameworks"
      ]
    },

    "capa_4_persistencia": {
      "nombre": "Persistencia / Data Access Layer",
      "ubicacion": "internal/domain/*/repository.go",
      "responsabilidad": "Abstraer el acceso a datos",
      "componentes": ["Repository interfaces", "Repository implementations", "Criteria"],
      "ejemplo_repo": "UserRepository.GetUser(criteria) ejecuta query SQL",
      "que_hace": [
        "Definir contratos de persistencia (interfaces)",
        "Implementar operaciones CRUD",
        "Construir queries dinámicas (Criteria)",
        "Mapear modelos de BD a dominio",
        "Manejar transacciones"
      ],
      "que_NO_hace": [
        "Validar reglas de negocio",
        "Conocer HTTP",
        "Exponer detalles de SQL al service"
      ]
    },

    "capa_5_infraestructura": {
      "nombre": "Infraestructura / External Services",
      "ubicacion": "pkg/, utils/",
      "responsabilidad": "Implementar detalles técnicos y acceso a servicios externos",
      "componentes": ["DB connections", "Loggers", "JWT", "External APIs", "Utils"],
      "ejemplo": "pkg/db/postgres.go conecta a PostgreSQL",
      "que_contiene": [
        "Implementaciones concretas de BD",
        "Clientes de APIs externas",
        "Sistema de logging",
        "Utilidades técnicas",
        "Generadores de tokens"
      ]
    }
  },

  "patrones_aplicados": {
    "repository_pattern": {
      "proposito": "Abstraer acceso a datos",
      "ubicacion": "repository.go en cada dominio",
      "implementacion": "Interface + struct privado + constructor",
      "ventaja": "Cambiar BD sin afectar services"
    },
    "service_layer_pattern": {
      "proposito": "Encapsular lógica de negocio",
      "ubicacion": "service.go en cada dominio",
      "implementacion": "Interface + struct privado + constructor",
      "ventaja": "Testeable, reutilizable, independiente de HTTP"
    },
    "criteria_pattern": {
      "proposito": "Queries dinámicas con filtros opcionales",
      "ubicacion": "repository.go - struct Criteria",
      "implementacion": "Struct con punteros para campos opcionales",
      "ventaja": "Un solo método para múltiples búsquedas"
    },
    "builder_pattern": {
      "proposito": "Construir objetos complejos con sintaxis fluida",
      "ubicacion": "repository.go - FindOptions",
      "implementacion": "Métodos que retornan *self para encadenar",
      "ventaja": "Paginación y ordenamiento flexible"
    },
    "dto_pattern": {
      "proposito": "Desacoplar representación HTTP de dominio",
      "ubicacion": "dto.go en cada dominio",
      "implementacion": "Structs con json tags + métodos ToModel()",
      "ventaja": "Versionado de API, campos opcionales"
    },
    "dependency_injection": {
      "proposito": "Desacoplar creación de objetos",
      "ubicacion": "router.go",
      "implementacion": "Manual: crear dependencias y pasarlas a constructores",
      "ventaja": "Testing con mocks, bajo acoplamiento"
    },
    "adapter_pattern": {
      "proposito": "Adaptar interfaces externas a internas",
      "ubicacion": "handlers (HTTP → Service), pkg/ (DB, APIs)",
      "implementacion": "Capas que transforman datos entre protocolos",
      "ventaja": "Cambiar frameworks sin tocar dominio"
    },
    "constructor_pattern": {
      "proposito": "Encapsular creación de objetos",
      "ubicacion": "Funciones NewRepository, NewService, NewHandler",
      "implementacion": "func New*(deps) Interface { return &struct{deps} }",
      "ventaja": "Retornar interfaces, inyectar dependencias"
    }
  },

  "flujo_datos_completo": {
    "request": {
      "1_entrada": "Cliente HTTP → POST /api/users",
      "2_router": "Router encuentra la ruta → UserHandler.Create",
      "3_middleware": "Middleware valida auth → next()",
      "4_handler": "Handler.Create() parsea JSON → UserDTO",
      "5_service": "Service.Create(dto) valida y ejecuta negocio",
      "6_repository": "Repository.InsertOne() persiste en BD",
      "7_database": "BD ejecuta INSERT y retorna ID",
      "response_flow": "BD → Repository → Service → Handler → Router → Cliente"
    }
  },

  "reglas_implementacion": {
    "naming_conventions": {
      "interfaces": "type Repository interface, type Service interface",
      "structs_privados": "type repository struct, type service struct",
      "constructores": "func NewRepository() Repository",
      "metodos_repo": "InsertOne, GetByID, GetAll, Update, Delete, Exists",
      "metodos_service": "Create, GetByID, GetAll, Update, Delete"
    },
    "dependency_flow": {
      "correcto": "Handler → Service (interface) → Repository (interface) → DB",
      "incorrecto_1": "Handler → Repository (saltarse service)",
      "incorrecto_2": "Service → SQL directo (saltarse repository)"
    },
    "error_handling": {
      "dominio": "Definir errores custom en errors.go",
      "service": "Retornar errores del dominio",
      "handler": "Transformar errores a HTTP status codes",
      "repository": "Propagar errores hacia arriba"
    },
    "testing": {
      "unit_tests_service": "Usar mocks del Repository",
      "unit_tests_handler": "Usar mocks del Service",
      "integration_tests_repo": "Usar BD de test real"
    }
  },

  "tecnologias_recomendadas": {
    "http_framework": {
      "opciones": ["gin-gonic/gin", "fiber", "echo", "chi"],
      "recomendado": "gin-gonic/gin",
      "razon": "Muy popular, rápido, buen middleware ecosystem"
    },
    "orm_database": {
      "opciones": ["GORM", "sqlx", "ent", "bob"],
      "recomendado": "sqlx o bob",
      "razon": "Control fino sobre SQL, buen performance"
    },
    "validacion": {
      "opciones": ["validator", "ozzo-validation"],
      "donde": "En service layer, no en handlers"
    },
    "testing": {
      "framework": "testing (stdlib) + testify/assert",
      "mocking": "mockery o gomock"
    },
    "config": {
      "opciones": ["viper", "godotenv"],
      "recomendado": "godotenv para simplicidad"
    }
  },

  "checklist_implementacion": {
    "paso_1_setup": [
      "Inicializar módulo Go",
      "Crear estructura de directorios",
      "Configurar .env y config.go"
    ],
    "paso_2_infraestructura": [
      "Implementar pkg/db/postgres.go",
      "Implementar pkg/logger/",
      "Implementar pkg/jwt/ si aplica"
    ],
    "paso_3_dominio": [
      "Crear internal/domain/[entidad]/",
      "Definir model.go",
      "Definir dto.go con ToModel()",
      "Definir errors.go",
      "Implementar repository.go (interface + impl)",
      "Implementar service.go (interface + impl)"
    ],
    "paso_4_presentacion": [
      "Crear handler en internal/http/handler/",
      "Implementar middlewares necesarios",
      "Configurar router.go con DI"
    ],
    "paso_5_main": [
      "Implementar cmd/api/main.go",
      "Cargar config",
      "Conectar BD",
      "Inicializar router",
      "Arrancar servidor"
    ]
  },

  "mejores_practicas": {
    "do": [
      "Usar interfaces para servicios y repositorios",
      "Inyectar dependencias via constructores",
      "Validar en service layer",
      "Usar DTOs para desacoplar capas",
      "Definir errores específicos del dominio",
      "Retornar interfaces desde constructores",
      "Usar Criteria para queries dinámicas",
      "Mantener handlers delgados (thin controllers)"
    ],
    "dont": [
      "No poner SQL en handlers",
      "No poner lógica de negocio en repositories",
      "No saltarse capas (handler → repository directo)",
      "No usar panic() para errores esperados",
      "No retornar modelos de BD en HTTP",
      "No hacer constructores que retornen structs concretos",
      "No mezclar responsabilidades de capas"
    ]
  },

  "ejemplo_minimo_viable": {
    "descripcion": "Estructura mínima para comenzar con un dominio 'user'",
    "archivos_requeridos": [
      "cmd/api/main.go",
      "internal/config/config.go",
      "internal/domain/user/model.go",
      "internal/domain/user/dto.go",
      "internal/domain/user/errors.go",
      "internal/domain/user/repository.go",
      "internal/domain/user/service.go",
      "internal/http/handler/user_handler.go",
      "internal/http/router.go",
      "pkg/db/postgres.go",
      "pkg/logger/logger.go",
      "go.mod"
    ]
  }
}
